    <#
    .SYNOPSIS
        Auto generate Citrix NetScaler functions
    
    .DESCRIPTION
        Auto generate Citrix NetScaler functions

       As is, this generates the new functions, and modifies Get-NSObjectList and Get-NSSessionCookie with the provided netscaler addresses.
       Before you rerun this script, replace Citrix.NetScaler folder with original files and remove any autogenerated functions.

    .Functionality
        NetScaler
   
    .PARAMETER NewModulePath
        Path to the root of this module...  Set to the current directory of this script.
    
    .PARAMETER allNetScalerAddresses
        All functions will be created with the address parameter limited to this set of addresses.  List all NetScalers you will need to work with.

    .PARAMETER defaultNetScalerAddress
        All functions will be created with this address as the the default for the address parameter
    
    .PARAMETER Address
        NetScaler address to use when autogenerating functions
    
    .PARAMETER Types
        Set to both config and stat.  If you change this, keep in mind it is case sensitive.
    
    .PARAMETER FunctionList
        Default action for this script is to create 900 + functions based on every single object we find on the NetScaler.  You can limit this to only objects you care about by providing an array of strings here
    
    .PARAMETER TrustAllCertsPolicy
        Sets your [System.Net.ServicePointManager]::CertificatePolicy to trust all certificates.  Remains in effect for the rest of the session.  See .\Functions\Set-TrustAllCertsPolicy.ps1 for details.  On by default
   
    .PARAMETER AllowHTTPAuth
        Allow HTTP.  Don't specify this uless you want authentication data to potentially be sent in clear text
    
    .NOTES
        Feel free to move things around.  The function name and script names can be moved around and modified if desired.   
    #>
[cmdletbinding()]
param(
    [string]$NewModulePath =$(split-path -parent $MyInvocation.MyCommand.Definition),

    [string[]]$allNetScalerAddresses = @( "CTX-NS-01","CTX-NS-02","CTX-NS-03","CTX-NS-04","CTX-NS-TST-01","CTX-NS-TST-02"),

    [string]$defaultNetScalerAddress = "CTX-NS-TST-01",

    [string]$address = "CTX-NS-TST-01",

    [validateset("config","stat")][string[]]$types = @( "Config", "Stat" ),

    [string[]]$FunctionList = $null,

    [bool]$TrustAllCertsPolicy = $true,

    [switch]$AllowHTTPAuth
)

#Define the base function text.  We will replace things as follows:
    #ZOBJECTTYPEZ = objecttype; config or stat
    #ZOBJECTNAMEZ = object name; one of hundreds we will pull from the NetScaler with Get-NSObjectList
    #Feel free to change the name of the function by moving these strings around!

#string to replace for validateset
    $allNetScalerAddressesString = ( $allNetScalerAddresses | %{"`"$_`""} ) -join ","

$baseFunction = @"
Function Get-NSZOBJECTNAMEZZOBJECTTYPEZ {
    <#
    .SYNOPSIS
        Get ZOBJECTNAMEZs on a NetScaler

    .PARAMETER Address
        Hostname for the NetScaler

    .PARAMETER Credential
        PSCredential object to authenticate with NetScaler.  Prompts if you don't provide one.

    .PARAMETER WebSession
        If specified, use an existing web session rather than an explicit credential
    
    .PARAMETER ZOBJECTNAMEZ
        Specific ZOBJECTNAMEZ name to query for

    .PARAMETER Raw
        If specified, don't select ZOBJECTNAMEZ from Invoke-RESTMethod command

    .PARAMETER AllowHTTPAuth
        Allow HTTP.  Don't specify this uless you want authentication data to potentially be sent in clear text

    .PARAMETER TrustAllCertsPolicy
        Sets your [System.Net.ServicePointManager]::CertificatePolicy to trust all certificates.  Remains in effect for the rest of the session.  See .\Functions\Set-TrustAllCertsPolicy.ps1 for details.  On by default

    .EXAMPLE
        #View ZOBJECTNAMEZ on CTX-NS-TST-01 
        Get-NSZOBJECTTYPEZZOBJECTNAMEZ -WebSession `$session | Out-Gridview

    .EXAMPLE
        #Explore all properties for ZOBJECTNAMEZ SomeValidZOBJECTNAMEZ on CTX-NS-03
        Get-NSZOBJECTTYPEZZOBJECTNAMEZ -Address CTX-NS-03 -Credential (Get-Credential) -ZOBJECTNAMEZ SomeValidZOBJECTNAMEZ | Out-Gridview

    .FUNCTIONALITY
        NetScaler
    #>
    [cmdletbinding()]
    param(
    
        [validateset($allNetScalerAddressesString)]
        [string]`$Address = "$defaultNetScalerAddress",

        [System.Management.Automation.PSCredential]`$Credential = `$null,

        [Microsoft.PowerShell.Commands.WebRequestSession]`$WebSession = `$null,

        #This might need further validation and/or sanitization
        [validatescript({`$_ -notmatch '[^a-zA-Z0-9-_]'})][string]`$ZOBJECTNAMEZ = `$null,

        [switch]`$Raw,

        [switch]`$AllowHTTPAuth,

        [bool]`$TrustAllCertsPolicy = `$true

    )

    #Run Set-TrustAllCertsPolicy unless otherwise specified.
    if( `$TrustAllCertsPolicy )
    {
        Set-TrustAllCertsPolicy
    }

    #Define the URI
    `$uri = "https://`$address/nitro/v1/config/ZOBJECTNAMEZ/"
    
    if(`$ZOBJECTNAMEZ){
        `$uri += `$ZOBJECTNAMEZ
    }
    
    #If no credential or web session is provided, get a credential
        if(-not `$WebSession -and -not `$Credential)
        {
            Write-Warning "No WebSession or Credential provided.  Please provide credentials"
            `$Credential = `$( Get-Credential -Message "Provide credentials for '`$Address'" )
            if(-not `$Credential)
            {
                break
            }
        }

    #Build up invoke-Restmethod parameters based on input
        `$IRMParam = @{
            Method = "Get"
            URI = `$uri
            ErrorAction = "Stop" 
        }
        If(`$Credential)
        {
            `$IRMParam.add("Credential",`$Credential)
        }
        If(`$WebSession)
        {
            `$IRMParam.add("WebSession",`$WebSession)
        }


    #Collect results
        `$result = `$(
            Try
            {
                Invoke-RestMethod @IRMParam
            }
            Catch
            {
                write-warning "Error: `$_"
                if(`$AllowHTTPAuth)
                {
                    Write-Verbose "Reverting to HTTP"
                    `$IRMParam["uri"] = `$uri -replace "^https","http"
                    Invoke-RestMethod @IRMParam
                }
            }
        )

    #Expand out the list, or provide full response if we got an unexpected errorcode
        if(`$result.errorcode -eq 0 -and -not `$Raw)
        {
            `$result | select -ExpandProperty ZOBJECTNAMEZ
        }
        else
        {
            if(-not `$Raw)
            {
                Write-Error "Something went wrong"
            }
            `$result
        }


}
"@


$FunctionsPath = Join-Path $NewModulePath "Functions"
$AutogenFunctionsPath = Join-Path $NewModulePath "AutogenFunctions"

#Load up functions
if(-not (test-path $FunctionsPath -ErrorAction SilentlyContinue)){
    "FunctionsPath '$FunctionsPath' is not valid..."
    Break
}
else{

    #replace address set and default value in existing functions
    $nsobjectpath = Join-Path $FunctionsPath Get-NSObjectList.ps1
    $nssessionpath = Join-Path $FunctionsPath Get-NSSessionCookie.ps1
    foreach($file in @($nsobjectpath, $nssessionpath)){
        $content = ( Get-Content $file ).replace('$Address = $null',"[validateset($allNetScalerAddressesString)]`n        `$Address = `$null").Replace('$Address = $null',"`$Address = `"$defaultNetScalerAddress`"")
        Set-Content $file $content -force
    }

    #import functions
    Get-ChildItem $FunctionsPath -filter *.ps1 | %{
        . "$($_.fullname)"
    }
}

if( $TrustAllCertsPolicy ){
    Set-TrustAllCertsPolicy
}

#build up params for get-ns*
$params = @{
    Address = $address
}
if($AllowHTTPAuth){
    $params.add( "AllowHTTPAuth", $true)
}

Try{
#Get a session on NS.  Test user with no privs outside of test NS, so I don't care if sent via HTTP
    $session = Get-NSSessionCookie @params -Credential (Get-Credential) -ErrorAction stop
}
Catch{
    "Something went wrong: $_"
}
if(-not $session){
    Write-Error: "Something went wrong:  No session obtained on $address"
    Break
}

foreach($configtype in $types){
     
    #List config names. 
        $ConfigNames = Get-NSObjectList @params -WebSession $session -ObjectType $configtype.ToLower()
    
    #If specified, only include the functionlist functions
    if($FunctionList){
        $ConfigNames = $ConfigNames | ?{$FunctionList -contains $_}
    }

    #Loop through config names, generate script content, create file
    Foreach($configname in $ConfigNames){
        
        If(-not (Test-Path $AutogenFunctionsPath -ErrorAction SilentlyContinue)){
            New-Item $AutogenFunctionsPath -ItemType Directory -force | out-null
        }
        #Change this name as well if desired by moving around configname and configtype
        $filepath = Join-Path $AutogenFunctionsPath "Get-NS$configname$configtype.ps1"
        
        #replace string references with configname and type, create the scripts
        $content = $baseFunction.replace("ZOBJECTNAMEZ",$configname).Replace("ZOBJECTTYPEZ",$configtype)
        Set-Content -path $filepath -Value $content
    }
}